/**
 * @file Transparency, a macro-dataflow language
 * @author Luddy Harrison <luddy@coreograph.com>
 * @license MIT
 */

/// <reference types="tree-sitter-cli/dsl" />
// @ts-check

module.exports = grammar({
  name: "transparency",

  extras: $ => [
    /\s/, // Whitespace
    $.comment
  ],

  rules: {
    source_file: $ => repeat($._statement),

    _statement: $ => choice(
      $.function_definition,
      $.class_definition,
      $.method_definition,
      $.variable_definition,
      $.constant_definition,
      $.type_definition,
      $.enum_definition,
      $.expression,
      $.assignment,
      $.pragma,
      $.circuit_definition,
      $.entry_definition
    ),

    function_definition: $ => seq(
      "function", 
      $.type_tuple, 
      $.identifier, 
      $.type_tuple, 
      $.block
    ),

    entry_definition: $ => seq(
      "entry",
      $.type_tuple, 
      $.identifier,
      $.type_tuple,
      $.entry_scope
    ),

    method_definition: $ => seq(
      "method", 
      optional("!"), 
      $.identifier, 
      optional(seq(":", $.typespec)),
      choice(";", $.block)
    ),

    class_definition: $ => seq(
      choice("class", "node"),
      $.identifier,
      optional(seq(":", $.base_specifier_list)),
      $.block
    ),

    base_specifier_list: $ => seq(
      $.base_specifier,
      repeat(seq(",", $.base_specifier))
    ),

    base_specifier: $ => seq(
      optional("common"),
      $.identifier
    ),

    variable_definition: $ => seq(
      choice("var", "ref"),
      $.id_list,
      choice(
        seq(":", $.typespec, optional(seq("=", $.expression))),
        seq("=", $.expression)
      ),
      ";"
    ),

    constant_definition: $ => seq(
      "constant", 
      $.identifier, 
      optional(seq(":", $.typespec)),
      "=", 
      $.expression, 
      ";"
    ),

    type_definition: $ => seq(
      "type", 
      $.identifier, 
      "=", 
      $.typespec, 
      ";"
    ),

    enum_definition: $ => seq(
      "enum", 
      $.typespec, 
      "{", 
      repeat(seq($.identifier, optional(seq("=", $.expression)), optional(","))),
      "}"
    ),

    circuit_definition: $ => seq(
      "circuit",
      $.identifier,
      $.type_tuple,
      $.circuit_scope
    ),

    circuit_scope: $ => seq(
      "{",
      repeat(choice(
        $.type_definition,
        $.enum_definition,
        $.constant_definition,
        $.function_definition,
        $.variable_definition,
        $.node_instantiation,
        $.circuit_instantiation,
        $.expression,
        $.assignment,
        ";"
      )),
      "}"
    ),

    entry_scope: $ => seq(
      "{",
      repeat(choice(
        $.type_definition,
        $.enum_definition,
        $.constant_definition,
        $.function_definition,
        $.variable_definition,
        $.node_instantiation,
        $.circuit_instantiation,
        $.fork_statement,
        $.return_statement,
        $.expression,
        $.assignment,
        ";"
      )),
      "}"
    ),

    node_instantiation: $ => seq("node", optional($.integer), optional($.string), $.expression, ";"),
    circuit_instantiation: $ => seq("circuit", optional($.integer), $.expression, ";"),
    fork_statement: $ => seq(choice("fork", "spawn"), $.expression, ";"),
    return_statement: $ => seq("return", optional($.expression), ";"),

    id_list: $ => seq(
      $.identifier,
      repeat(seq(",", $.identifier))
    ),

    typespec: $ => choice(
      $.type,
      seq($.qualified_type, $.typespec),
      seq($.type, $.type_ctor_args),
      seq($.type, "->", $.type_tuple),
      seq($.type, "+", $.typespec)
    ),

    type: $ => choice(
      $.identifier,
      $.basic_type,
      $.constructed_type,
      $.signature_type
    ),

    basic_type: $ => choice(
      "string", "symbol", "regex", "match", "blob",
      "int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64",
      "float32", "float64", "codepoint", "bool"
    ),

    constructed_type: $ => choice(
      "bitset", "idxset", "vector", "tensor", "deque", "pqueue", "wire", "map", "ordmap", "set", "ordset", "list", "table",
      "in", "out", "trigger", "device", "buffer", "stream"
    ),

    signature_type: $ => seq(
      "[", optional(seq($.method_signature, repeat(seq(",", $.method_signature)))), "]"
    ),

    method_signature: $ => seq($.identifier, ":", $.typespec),

    qualified_type: $ => choice(
      "shared", "const"
    ),

    type_ctor_args: $ => seq(
      "[", optional(seq($.expression, repeat(seq(",", $.expression)))), "]"
    ),

    block: $ => seq("{", repeat($._statement), "}"),

    assignment: $ => seq($.identifier, "=", $.expression),

    expression: $ => choice(
      $.binary_expression,
      $.unary_expression,
      $.function_call,
      $.literal,
      $.identifier
    ),

    binary_expression: $ => prec.left(choice(
      seq($.expression, choice(
        "||", "&&", "==", "!=", "<", ">", "<=", ">=", 
        "|", "^", "~", "&", "<~", "~>", "+", "-", "*", "/", "%",
        "=", "+=", "-=", "*=", "/=", "%=", "|=", "&=", "^=", "~="
      ), $.expression)
    )),

    unary_expression: $ => prec.right(choice(
      seq(choice("-", "+", "!", "~", "\\"), $.expression)
    )),

    function_call: $ => seq($.identifier, "(", optional(seq($.expression, repeat(seq(",", $.expression)))), ")"),

    identifier: $ => token(/[a-zA-Z_\$][a-zA-Z0-9_]*(::[a-zA-Z_\$][a-zA-Z0-9_]*)*/),
    pragma: $ => seq("#", choice("echo", "expect", "meta", "xml"), optional($.expression)),

    comment: $ => token(choice(
      seq("//", /.*/),
      seq("/*", /[^*]*\*+([^/*][^*]*\*+)*/, "/")
    ))
  }
});
